// -*- mode:C++; tab-width:4; c-basic-offset:4; indent-tabs-mode:nil -*-

/*

  SpinnIO Test program to concurrently send and receive spikes
  to/from SpiNNaker using the EIEIO protocol 

*/



#include <EIEIOReceiver.h>
#include <EIEIOSender.h>

#include <stdio.h>
#include <string>
#include <time.h>
#include <unistd.h>

using namespace std;
using namespace spinnio;


int main(int argc, char *argv[]) 
{
    
    int spinn_port = 17895;
    int send_port = 12346;
    string spinn_ip = "192.168.1.1";
    string db = "/home/ubuntu/spinn103/examples/application_generated_data_files/latest/input_output_database.db";

    // Create the receiver (creates socket and does toolchain handshake)
    // The port needs to be whatever port is defined for SpiNNaker
    // in the central or user spynnaker.cfg
    // the IP should be the SpiNNaker board IP
    // the database path is the path to the database created by the toolchain
    // for whatever network is being run

    // Creating Receiver then Sender
    
    EIEIOReceiver *myReceiver = new EIEIOReceiver(spinn_port,(char*)spinn_ip.c_str(), true, (char*)db.c_str());

    // get pointer to id-key map for sending

    std::map<int,int>* keymap = myReceiver->getIDKeyMap();

    // Create the sender, passing in keymap generated by the receiver
    // Note using a different port here which must match
    // what is set in the PyNN script for the population
    // you are sending spikes to

    EIEIOSender *mySender = new EIEIOSender(send_port,(char*)spinn_ip.c_str(), keymap);
    
    
    
    // start the receiver thread
    myReceiver->start();

    // start the sender thread
    mySender->start();

    int numSpikes = 0;
    int neuronID = 20;
    int stepsToRun = 50;
    int count = 0;

    // Preload some spikes to send queue
    // this should create two packets
    // with 63 spikes and one with 20
    for (int s=0; s < 146; s++){

       mySender->addSpikeToSendQueue(neuronID);
       if (neuronID == 20){
        neuronID = 21;
       }else{
        neuronID = 20;
       }

    }
    // enable the queue for processing

    mySender->enableSendQueue();  

    // run for the number of steps defined above
    while(count < stepsToRun){
      int recvSize = myReceiver->getRecvQueueSize();
      int sendSize = mySender->getSendQueueSize();

      // If there are incoming packets in the receiver queue
      // then process them and increment count of spikes

      printf("recv %d send %d\n", recvSize, sendSize);

      if (recvSize > 0){
         // get the next packet from the queue
         list<pair<int, int> > spikeEvents = myReceiver->getNextSpikePacket();
         // get the individual spikes from the packet
         for(list<pair<int, int> >::iterator iter = spikeEvents.begin();iter != spikeEvents.end(); ++iter) {
            pair<int,int> spikeEvent = *iter;
            printf("Time %d, ID %d\n", spikeEvent.first, spikeEvent.second);
            // erase (time, nrn id) pair from list
            iter = spikeEvents.erase(iter);
            numSpikes++;
         }
      }
      // continue to add new spikes to the send queue
      mySender->addSpikeToSendQueue(neuronID);
      if (neuronID == 20){
       neuronID = 21;
      }else{
       neuronID = 20;
      }

      // wait here 

      usleep(1000000);

      count++;

    } // main processing loop

    printf("Finished, cleaning up.....\n");

    // clean up

    // close sockets

    myReceiver->closeRecvSocket();
    mySender->closeSendSocket();

    // nullify sender and receiver objects
    
    myReceiver = NULL;
    mySender = NULL;

}



